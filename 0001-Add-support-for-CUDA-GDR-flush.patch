From 590a54f306f2a9729a0f06827bac85fece99a143 Mon Sep 17 00:00:00 2001
From: James Dinan <jdinan@nvidia.com>
Date: Thu, 30 Jun 2022 13:16:08 -0700
Subject: [PATCH 1/2] Add support for CUDA GDR flush

Add support for calling cudaDeviceFlushGPUDirectRDMAWrites on CUDA 11.3 and
later. Currently enabled by setting OFI_NCCL_CUDA_FLUSH_ENABLE.

Signed-off-by: James Dinan <jdinan@nvidia.com>
---
 include/nccl_ofi_param.h |  9 ++++++++-
 src/nccl_ofi_net.c       | 31 ++++++++++++++++++++++++++++++-
 2 files changed, 38 insertions(+), 2 deletions(-)

diff --git a/include/nccl_ofi_param.h b/include/nccl_ofi_param.h
index e59d130b..eb8ad555 100644
--- a/include/nccl_ofi_param.h
+++ b/include/nccl_ofi_param.h
@@ -92,8 +92,15 @@ OFI_NCCL_PARAM_STR(exclude_tcp_if, "EXCLUDE_TCP_IF", "lo,docker0");
  */
 OFI_NCCL_PARAM_INT(gdr_flush_disable, "GDR_FLUSH_DISABLE", 0);
 
+/*
+ * When using GPUDirect use the cudaDeviceFlushGPUDirectRDMAWrites
+ * to enforce data consistency at the receiving GPU. Requires CUDA 11.3 or
+ * later.
+ */
+OFI_NCCL_PARAM_INT(cuda_flush_enable, "CUDA_FLUSH_ENABLE", 0);
+
 #ifdef _cplusplus
 } // End extern "C"
 #endif
 
-#endif // End NCCL_OFI_PARAM_H_
\ No newline at end of file
+#endif // End NCCL_OFI_PARAM_H_
diff --git a/src/nccl_ofi_net.c b/src/nccl_ofi_net.c
index 8452e576..5c46f02f 100644
--- a/src/nccl_ofi_net.c
+++ b/src/nccl_ofi_net.c
@@ -1048,6 +1048,14 @@ static ncclResult_t ofi_init(ncclDebugLogger_t logFunction)
 
 	NCCL_OFI_INFO(NCCL_INIT | NCCL_NET, "Using " PACKAGE_STRING);
 
+#if CUDART_VERSION < 11030
+	if (ofi_cuda_flush_enable()) {
+		NCCL_OFI_WARN("CUDA flush requested, but CUDART_VERSION %ld < 11030", CUDART_VERSION)
+		ret = ncclSystemError;
+		goto exit;
+	}
+#endif
+
 	/*
 	 * FI_EFA_FORK_SAFE environment variable tells Libfabric to enable
 	 * fork-safe support in legacy versions of the rdma-core library.
@@ -2107,7 +2115,7 @@ static recvComm_t *prepare_recv_comm(listenComm_t *lComm, char *remote_ep_addr)
 	 * Setup flush resources if using GPUDirect RDMA unless user disables
 	 * flush operations
 	 */
-	if (!ofi_nccl_gdr_flush_disable() && support_gdr) {
+	if (!ofi_nccl_gdr_flush_disable() && support_gdr && !ofi_nccl_cuda_flush_enable()) {
 		rComm->flush_buff.size = NCCL_OFI_FLUSH_SIZE;
 		ret = alloc_and_reg_flush_buff(rComm);
 		if (OFI_UNLIKELY(ret != ncclSuccess)) {
@@ -2745,6 +2753,22 @@ static ncclResult_t ofi_iflush(void* recvComm, void* buffer, int size,
 	if (ofi_nccl_gdr_flush_disable() || !support_gdr)
 		goto exit;
 
+#if CUDART_VERSION >= 11030
+	if (ofi_nccl_cuda_flush_enable()) {
+		cudaError_t cuda_ret = cudaDeviceFlushGPUDirectRDMAWrites(
+						cudaFlushGPUDirectRDMAWritesTargetCurrentDevice,
+						cudaFlushGPUDirectRDMAWritesToOwner);
+
+		if (cuda_ret != cudaSuccess) {
+			ret = ncclUnhandledCudaError;
+			NCCL_OFI_WARN("Error performing CUDA GDR flush");
+			goto exit;
+		}
+
+		goto exit;
+	}
+#endif
+
 	/* Validate recvComm */
 	if (OFI_UNLIKELY(rComm == NULL)) {
 		ret = ncclSystemError;
@@ -2900,6 +2924,11 @@ static ncclResult_t ofi_flush(void* recvComm, void* data, int size,
 		goto exit;
 	}
 
+	/* ofi_iflush doesn't return a request when CUDA flush is enabled */
+	if (ofi_nccl_cuda_flush_enable()) {
+		goto exit;
+	}
+
 	/* Ensure that the request completes */
 	while (done == 0) {
 		ret = ofi_test(req, &done, NULL);
-- 
2.34.1

